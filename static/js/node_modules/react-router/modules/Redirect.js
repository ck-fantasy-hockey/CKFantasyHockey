import React from "react";
import PropTypes from "prop-types";
import { createLocation, locationsAreEqual } from "history";
import invariant from "tiny-invariant";

import Lifecycle from "./Lifecycle.js";
import RouterContext from "./RouterContext.js";
import generatePath from "./generatePath.js";

/**
 * The public API for navigating programmatically with a component.
 */
function Redirect(_ref) {
  var computedMatch = _ref.computedMatch,
      to = _ref.to,
      _ref$push = _ref.push,
      push = _ref$push === undefined ? false : _ref$push;

  return React.createElement(
    RouterContext.Consumer,
    null,
    function (context) {
      invariant(context, "You should not use <Redirect> outside a <Router>");

      var history = context.history,
          staticContext = context.staticContext;


      var method = push ? history.push : history.replace;
      var location = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : Object.assign({}, to, {
        pathname: generatePath(to.pathname, computedMatch.params)
      }) : to);

      // When rendering in a static context,
      // set the new location immediately.
      if (staticContext) {
        method(location);
        return null;
      }

      return React.createElement(Lifecycle, {
        onMount: function onMount() {
          method(location);
        },
        onUpdate: function onUpdate(self, prevProps) {
          var prevLocation = createLocation(prevProps.to);
          if (!locationsAreEqual(prevLocation, Object.assign({}, location, {
            key: prevLocation.key
          }))) {
            method(location);
          }
        },
        to: to
      });
    }
  );
}

if (__DEV__) {
  Redirect.propTypes = {
    push: PropTypes.bool,
    from: PropTypes.string,
    to: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired
  };
}

export default Redirect;